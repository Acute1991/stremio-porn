{"version":3,"sources":["../../src/adapters/BaseAdapter.js"],"names":["BaseAdapter","constructor","httpClient","scheduler","Bottleneck","maxConcurrent","MAX_CONCURRENT_REQUESTS","_normalizeItem","item","_normalizeStream","stream","name","_paginate","request","itemsPerPage","ITEMS_PER_PAGE","Infinity","skip","limit","Math","min","MAX_RESULTS_PER_REQUEST","firstPage","ceil","pageCount","pages","i","length","push","skipOnFirstPage","_validateRequest","typeRequired","SUPPORTED_TYPES","Error","query","type","includes","_find","pagination","requests","map","page","_findByPage","results","Promise","all","concat","filter","slice","find","schedule","getItem","id","result","_getItem","getStreams","_getStreams"],"mappings":"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","sourcesContent":["import Bottleneck from 'bottleneck'\n\n\n// Contains some common methods as well as public wrappers\n// that prepare requests, redirect them to private methods\n// and normalize results\nclass BaseAdapter {\n  static SUPPORTED_TYPES = []\n  static MAX_RESULTS_PER_REQUEST = 100\n  static MAX_CONCURRENT_REQUESTS = 3\n\n  constructor(httpClient) {\n    this.httpClient = httpClient\n    this.scheduler = new Bottleneck({\n      maxConcurrent: this.constructor.MAX_CONCURRENT_REQUESTS,\n    })\n  }\n\n  _normalizeItem(item) {\n    return item\n  }\n\n  _normalizeStream(stream) {\n    if (stream.name) {\n      return stream\n    } else {\n      return { ...stream, name: this.constructor.name }\n    }\n  }\n\n  _paginate(request) {\n    let itemsPerPage = this.constructor.ITEMS_PER_PAGE || Infinity\n    let { skip = 0, limit = itemsPerPage } = request\n    limit = Math.min(limit, this.constructor.MAX_RESULTS_PER_REQUEST)\n    itemsPerPage = Math.min(itemsPerPage, limit)\n\n    let firstPage = Math.ceil((skip + 0.1) / itemsPerPage) || 1\n    let pageCount = Math.ceil(limit / itemsPerPage)\n    let pages = []\n\n    for (let i = firstPage; pages.length < pageCount; i++) {\n      pages.push(i)\n    }\n\n    return {\n      pages, skip, limit,\n      skipOnFirstPage: skip % itemsPerPage,\n    }\n  }\n\n  _validateRequest(request, typeRequired) {\n    let { SUPPORTED_TYPES } = this.constructor\n\n    if (typeof request !== 'object') {\n      throw new Error(`A request must be an object, ${typeof request} given`)\n    }\n\n    if (!request.query) {\n      throw new Error('Request query must not be empty')\n    }\n\n    if (typeRequired && !request.query.type) {\n      throw new Error('Content type must be specified')\n    }\n\n    if (request.query.type && !SUPPORTED_TYPES.includes(request.query.type)) {\n      throw new Error(`Content type ${request.query.type} is not supported`)\n    }\n  }\n\n  async _find(query, pagination) {\n    let { pages, limit, skipOnFirstPage } = pagination\n    let requests = pages.map((page) => {\n      return this._findByPage(query, page)\n    })\n\n    let results = await Promise.all(requests)\n    results = [].concat(...results).filter((item) => item)\n    return results.slice(skipOnFirstPage, skipOnFirstPage + limit)\n  }\n\n  async find(request) {\n    this._validateRequest(request)\n\n    let pagination = this._paginate(request)\n    let { query } = request\n\n    if (!query.type) {\n      query = {\n        ...query,\n        type: this.constructor.SUPPORTED_TYPES[0],\n      }\n    }\n\n    let results = await this.scheduler.schedule(() => {\n      return this._find(query, pagination)\n    })\n\n    if (results) {\n      return results.map((item) => this._normalizeItem(item))\n    } else {\n      return []\n    }\n  }\n\n  async getItem(request) {\n    this._validateRequest(request, true)\n\n    let { type, id } = request.query\n    let result = await this.scheduler.schedule(() => {\n      return this._getItem(type, id)\n    })\n    return result ? [this._normalizeItem(result)] : []\n  }\n\n  async getStreams(request) {\n    this._validateRequest(request, true)\n\n    let { type, id } = request.query\n    let results = await this.scheduler.schedule(() => {\n      return this._getStreams(type, id)\n    })\n\n    if (results) {\n      return results.map((stream) => this._normalizeStream(stream))\n    } else {\n      return []\n    }\n  }\n}\n\n\nexport default BaseAdapter\n"],"file":"BaseAdapter.js"}