{"version":3,"sources":["../../src/adapters/BaseAdapter.js"],"names":["BaseAdapter","constructor","httpClient","scheduler","Bottleneck","maxConcurrent","MAX_CONCURRENT_REQUESTS","_normalizeItem","item","_normalizeStream","stream","name","_paginate","request","itemsPerPage","ITEMS_PER_PAGE","Infinity","skip","limit","Math","min","MAX_RESULTS_PER_REQUEST","firstPage","ceil","pageCount","pages","i","length","push","skipOnFirstPage","_validateRequest","type","SUPPORTED_TYPES","Error","query","includes","_find","pagination","requests","map","page","_findByPage","results","Promise","all","concat","filter","slice","find","schedule","getItem","id","result","_getItem","getStreams","_getStreams"],"mappings":"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","sourcesContent":["import Bottleneck from 'bottleneck'\n\n\n// Contains some common methods as well as public wrappers\n// that prepare requests, redirect them to private methods\n// and normalize results\nclass BaseAdapter {\n  static SUPPORTED_TYPES = []\n  static MAX_RESULTS_PER_REQUEST = 100\n  static MAX_CONCURRENT_REQUESTS = 3\n\n  constructor(httpClient) {\n    this.httpClient = httpClient\n    this.scheduler = new Bottleneck({\n      maxConcurrent: this.constructor.MAX_CONCURRENT_REQUESTS,\n    })\n  }\n\n  _normalizeItem(item) {\n    return item\n  }\n\n  _normalizeStream(stream) {\n    if (stream.name) {\n      return stream\n    } else {\n      return { ...stream, name: this.constructor.name }\n    }\n  }\n\n  _paginate(request) {\n    let itemsPerPage = this.constructor.ITEMS_PER_PAGE || Infinity\n    let { skip = 0, limit = itemsPerPage } = request\n    limit = Math.min(limit, this.constructor.MAX_RESULTS_PER_REQUEST)\n    itemsPerPage = Math.min(itemsPerPage, limit)\n\n    let firstPage = Math.ceil((skip + 0.1) / itemsPerPage) || 1\n    let pageCount = Math.ceil(limit / itemsPerPage)\n    let pages = []\n\n    for (let i = firstPage; pages.length < pageCount; i++) {\n      pages.push(i)\n    }\n\n    return {\n      pages, skip, limit,\n      skipOnFirstPage: skip % itemsPerPage,\n    }\n  }\n\n  _validateRequest(request) {\n    let type = typeof request\n    let { SUPPORTED_TYPES } = this.constructor\n\n    if (type !== 'object') {\n      throw new Error(`A request must be an object, ${type} given`)\n    }\n\n    if (!request.query) {\n      throw new Error('Request query must not be empty')\n    }\n\n    if (!SUPPORTED_TYPES.includes(request.query.type)) {\n      throw new Error(`Content type ${request.query.type} is not supported`)\n    }\n  }\n\n  async _find(query, pagination) {\n    let { pages, limit, skipOnFirstPage } = pagination\n    let requests = pages.map((page) => {\n      return this._findByPage(query, page)\n    })\n\n    let results = await Promise.all(requests)\n    results = [].concat(...results).filter((item) => item)\n    return results.slice(skipOnFirstPage, skipOnFirstPage + limit)\n  }\n\n  async find(request) {\n    this._validateRequest(request)\n\n    let pagination = this._paginate(request)\n    let results = await this.scheduler.schedule(() => {\n      return this._find(request.query, pagination)\n    })\n\n    if (results) {\n      return results.map((item) => this._normalizeItem(item))\n    } else {\n      return []\n    }\n  }\n\n  async getItem(request) {\n    this._validateRequest(request)\n\n    let { type, id } = request.query\n    let result = await this.scheduler.schedule(() => {\n      return this._getItem(type, id)\n    })\n    return result ? [this._normalizeItem(result)] : []\n  }\n\n  async getStreams(request) {\n    this._validateRequest(request)\n\n    let { type, id } = request.query\n    let results = await this.scheduler.schedule(() => {\n      return this._getStreams(type, id)\n    })\n\n    if (results) {\n      return results.map((stream) => this._normalizeStream(stream))\n    } else {\n      return []\n    }\n  }\n}\n\n\nexport default BaseAdapter\n"],"file":"BaseAdapter.js"}