{"version":3,"sources":["../src/PornClient.js"],"names":["ID","SORT_PROP_PREFIX","MAX_ADAPTERS_PER_REQUEST","ADAPTERS","PornHub","RedTube","YouPorn","SpankWire","PornCom","Chaturbate","SORTS","map","name","DISPLAY_NAME","SUPPORTED_TYPES","prop","types","METHODS","adapterMethod","cacheTtl","idProp","expectsArray","makePornId","adapter","type","id","parsePornId","pornId","split","pop","normalizeRequest","request","query","sort","limit","skip","adapters","Object","keys","filter","p","startsWith","slice","length","search","porn_id","Error","includes","normalizeResult","item","newItem","constructor","mergeResults","results","reduce","adapterResults","push","PornClient","options","httpClient","HttpClient","Adapter","cache","cacheManager","caching","store","redisStore","url","_getAdaptersForRequest","matchingAdapters","_invokeAdapterMethod","method","result","_invokeMethod","methodName","rawRequest","invokeMethod","cacheKey","JSON","stringify","cacheOptions","ttl","wrap"],"mappings":"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","sourcesContent":["import cacheManager from 'cache-manager'\nimport redisStore from 'cache-manager-redis-store'\nimport HttpClient from './HttpClient'\nimport PornHub from './adapters/PornHub'\nimport RedTube from './adapters/RedTube'\nimport YouPorn from './adapters/YouPorn'\nimport SpankWire from './adapters/SpankWire'\nimport PornCom from './adapters/PornCom'\nimport Chaturbate from './adapters/Chaturbate'\n\n// EPorner has restricted video downloads to 30 per day per guest\n// import EPorner from './adapters/EPorner'\n\n\nconst ID = 'porn_id'\nconst SORT_PROP_PREFIX = 'popularities.porn.'\nconst MAX_ADAPTERS_PER_REQUEST = 1\nconst ADAPTERS = [PornHub, RedTube, YouPorn, SpankWire, PornCom, Chaturbate]\nconst SORTS = ADAPTERS.map(({ name, DISPLAY_NAME, SUPPORTED_TYPES }) => ({\n  name: `Porn: ${DISPLAY_NAME}`,\n  prop: `${SORT_PROP_PREFIX}${name}`,\n  types: SUPPORTED_TYPES,\n}))\nconst METHODS = {\n  'stream.find': {\n    adapterMethod: 'getStreams',\n    cacheTtl: 300,\n    idProp: ID,\n    expectsArray: true,\n  },\n  'meta.find': {\n    adapterMethod: 'find',\n    cacheTtl: 300,\n    idProp: 'id',\n    expectsArray: true,\n  },\n  'meta.search': {\n    adapterMethod: 'find',\n    cacheTtl: 3600,\n    idProp: 'id',\n    expectsArray: true,\n  },\n  'meta.get': {\n    adapterMethod: 'getItem',\n    cacheTtl: 300,\n    idProp: 'id',\n    expectsArray: false,\n  },\n}\n\n\nfunction makePornId(adapter, type, id) {\n  return `${ID}:${adapter}-${type}-${id}`\n}\n\nfunction parsePornId(pornId) {\n  let [adapter, type, id] = pornId.split(':').pop().split('-')\n  return { adapter, type, id }\n}\n\nfunction normalizeRequest(request) {\n  let { query, sort, limit, skip } = request\n  let adapters = []\n\n  if (sort) {\n    adapters = Object.keys(sort)\n      .filter((p) => p.startsWith(SORT_PROP_PREFIX))\n      .map((p) => p.slice(SORT_PROP_PREFIX.length))\n  }\n\n  if (typeof query === 'string') {\n    // Search requests are troublesome because they don't have a type specified,\n    // and making multiple requests to multiple adapters for different types\n    // and then aggregating them is a lot of work.\n    // So we only support searching for movies for now.\n    query = { search: query, type: 'movie' }\n  } else if (query) {\n    query = { ...query }\n  } else {\n    query = {}\n  }\n\n  if (query.porn_id) {\n    let { adapter, type, id } = parsePornId(query.porn_id)\n\n    if (type && query.type && type !== query.type) {\n      throw new Error(\n        `Request query and porn_id types do not match (${type}, ${query.type})`\n      )\n    }\n\n    if (adapters.length && !adapters.includes(adapter)) {\n      throw new Error(\n        `Request sort and porn_id adapters do not match (${adapter})`\n      )\n    }\n\n    adapters = [adapter]\n    query.type = type\n    query.id = id\n  }\n\n  return { query, adapters, skip, limit }\n}\n\nfunction normalizeResult(adapter, item, idProp = 'id') {\n  let newItem = { ...item }\n  newItem[idProp] = makePornId(adapter.constructor.name, item.type, item.id)\n  return newItem\n}\n\nfunction mergeResults(results) {\n  // TODO: limit\n  return results.reduce((results, adapterResults) => {\n    results.push(...adapterResults)\n    return results\n  }, [])\n}\n\n\nclass PornClient {\n  static ID = ID\n  static ADAPTERS = ADAPTERS\n  static SORTS = SORTS\n\n  constructor(options) {\n    let httpClient = new HttpClient(options)\n    this.adapters = ADAPTERS.map((Adapter) => new Adapter(httpClient))\n\n    if (options.cache === '1') {\n      this.cache = cacheManager.caching({ store: 'memory' })\n    } else if (options.cache && options.cache !== '0') {\n      this.cache = cacheManager.caching({\n        store: redisStore,\n        url: options.cache,\n      })\n    }\n  }\n\n  _getAdaptersForRequest(request) {\n    let { query, adapters } = request\n    let { type } = query\n    let matchingAdapters = this.adapters\n\n    if (adapters.length) {\n      matchingAdapters = matchingAdapters.filter((adapter) => {\n        return adapters.includes(adapter.constructor.name)\n      })\n    }\n\n    if (type) {\n      matchingAdapters = matchingAdapters.filter((adapter) => {\n        return adapter.constructor.SUPPORTED_TYPES.includes(type)\n      })\n    }\n\n    return matchingAdapters.slice(0, MAX_ADAPTERS_PER_REQUEST)\n  }\n\n  async _invokeAdapterMethod(adapter, method, request, idProp) {\n    let results = await adapter[method](request)\n    return results.map((result) => {\n      return normalizeResult(adapter, result, idProp)\n    })\n  }\n\n  // Aggregate method that dispatches requests to matching adapters\n  async _invokeMethod(methodName, rawRequest, idProp) {\n    let request = normalizeRequest(rawRequest)\n    let adapters = this._getAdaptersForRequest(request)\n\n    if (!adapters.length) {\n      throw new Error('Couldn\\'t find suitable adapters for a request')\n    }\n\n    let results = []\n\n    for (let adapter of adapters) {\n      let adapterResults = await this._invokeAdapterMethod(\n        adapter, methodName, request, idProp\n      )\n      results.push(adapterResults)\n    }\n\n    return mergeResults(results, request.limit)\n  }\n\n  // This is a public wrapper around the private method\n  // that implements caching and result normalization\n  async invokeMethod(methodName, rawRequest) {\n    let { adapterMethod, cacheTtl, idProp, expectsArray } = METHODS[methodName]\n    let invokeMethod = async () => {\n      let result = await this._invokeMethod(adapterMethod, rawRequest, idProp)\n      result = expectsArray ? result : result[0]\n      return result\n    }\n\n    if (this.cache) {\n      let cacheKey = JSON.stringify(rawRequest)\n      let cacheOptions = {\n        ttl: cacheTtl,\n      }\n      return this.cache.wrap(cacheKey, invokeMethod, cacheOptions)\n    } else {\n      return invokeMethod()\n    }\n  }\n}\n\n\nexport default PornClient\n"],"file":"PornClient.js"}